Transforming the data we have as input into a 8,16 and 32 bit data which later can be stored in a .wav file can be done in different ways.
After doing some reasearch  regarding the opportunities we have in CLEAN and discussing about the best approach we have made a decision to use the concept of vertical graph shifting and multiplying. The simplest vertical graph transformation involves adding a positive or negative constant to a function. In other words, we add the same constant to the output value of the function regardless of the input. For a function g(x)=f(x)+k, the function f(x) is shifted vertically k units. In order to give more detailed explanation of our idea and implementation we will handle the 8, 16 and 32 bits cases separately:
-8 bit case
The first thing we do is dividing each number from the list  with the maximal possible value the input values can reach. In the case of real numbers from [-0.5,0.5] we divide with 0.5. The next step is adding the max(0.5) and then multiplying each element by 255 (2^8-1) in order to get real numbers in [0,255] interval. After this we use toInt (build in function in Clean) in order to convert the real numbers into integers. As a last step we use toChar (build in function in Clean) which converts our list of integers to list of characters which are represented in 8 bits. 
If we have a list of lists as input we just map the same transformation to each and every sub list of the input.
-16 bit case
In the 16 bit case the first thing we do is applying a function which converts the input from list of real numbers to integers. In this case instead of using toInt we created a function which takes two real numbers (the number that we want to convert (lets name it x)and the maximal possible value the numbers in the list can reach (lets name it maxX) and returns 2^(16-1)-1 if the number equals to maxX or otherwise the lower integer part of x multiplied by 2^(16-1) and divided with maxX. After getting a list of integers we map a  function which converts each integer into a list of bits (1s and 0s) of length 16. The final step is just concatenating the list of 1s and 0s into one list.
If we have a list of lists as input we just map the same transformation to each and every sub list of the input.
-32 bit case 
The 32 bit conversion is pretty similar to the 16 bit case that we already handled. In the first step we map a function which converts the input from list of real numbers to integers but now instead of working with 2^(16-1) we work with 2^(32-1) but the concept is exactly the same. After that we convert each integers we get into a list of bits (1s and 0s) of length 32 and in the end just add all the 32-length lists into a big one.
If we have a list of lists as input we just map the same transformation to each and every sub list of the input.

 
