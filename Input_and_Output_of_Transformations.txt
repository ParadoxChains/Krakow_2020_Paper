A wavetable is a table of stored sound waves that are digitized samples of actual recorded sound . In our implementation we decided to set the size of our table to be 2205, meaning that we store a table of 2205 real numbers, representing consecutive amplitudes within one single vibration of the sound wave. Thus, achieving the minimum sound intensity that humans can hear, 20 Hz.
This wavetable is the main component of the actual sound data and in our case will be represented as a list (of lists) of type Real. Once we obtain this wavetable, we will have to proceed to the next step which is writing this sound data to a .wav file. 
If we take a look at the format of .wav file, we will see that it separated into three main components: the RIFF chunk, the fmt sub-chunk and the data sub-chunk. The data sub-chunk is the part which contains the actual sound information, which is stored in bytes. Because of that we had to find a way to convert our result of the wavetable into appropriate data for the file, hence we introduced the transform function. 
Initially we created the transform8 function which takes the wavetable and its maximum value and converts the values to fit the 8 bits range. In other words, we converted the wavetable values into an interval from 0 to 255. Later on, because we wanted to increase the quality of our generated sounds, we also added the transform16, which alters the value to 16 bits samples stored into the interval 0 to 2^16-1 (the integers range -32768 to 32767), and the transform32, which alters the value to 32 bits samples stored into the interval 0 to 2^32-1.
Because we were not fully sure of the exact way we would tackle the wavetable, we made two versions for the transform functions.  In the first case we assume that the sound data which we will get as the input will be in only one channel, meaning that the wavetable could be correctly represented as a list of Reals. On the other hand, in case we could have two or more channels then a better representation would be a list of lists of Real. That is why in addition to transform8, transform16 and transform32, we also created three more functions ,called transform8_what_if, transform16_what_if and transform32_what_if respectively, working with lists of lists where we just map the precious functions to each sub-list.
A predicted future step would be adding a rewritten code of the transform function which would work with arrays. Our current implementation using lists is quite readable and understandable since lists are very easy to handle. However, based in our experiments, while lists may be much easier to work with, arrays are much more efficient. Based on some hard-coding experiments we did the usage of arrays instead of lists brought an increasement of efficiency by X times.
